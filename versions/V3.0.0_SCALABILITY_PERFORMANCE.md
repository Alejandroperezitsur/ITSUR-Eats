# ğŸ”– v3.0.0 â€” Scalability & Performance

**Fecha de Lanzamiento Objetivo**: Mes 6 (6 semanas despuÃ©s de v2)
**DuraciÃ³n del Sprint**: 6 semanas
**Dependencias**: v2.0.0 completado con 2,000+ usuarios activos

---

## ğŸ¯ Objetivo de la VersiÃ³n

Optimizar la arquitectura para manejar miles de usuarios concurrentes con latencia mÃ­nima. Esta versiÃ³n introduce caching distribuido, real-time updates optimizados, escalabilidad horizontal automÃ¡tica, y CDN global. Preparar la plataforma para crecer de 2K a 5K usuarios sin degradaciÃ³n de rendimiento.

### Problemas Resueltos
- âŒ API lenta bajo carga alta â†’ âœ… CachÃ© distribuido con Redis
- âŒ Base de datos saturada â†’ âœ… Read replicas y optimizaciÃ³n
- âŒ WebSocket inestable â†’ âœ… Arquitectura real-time escalable
- âŒ ImÃ¡genes lentas â†’ âœ… CDN global con optimizaciÃ³n

### Habilita
- Soportar 5,000+ usuarios activos
- API latency < 100ms (p95)
- 99.99% uptime
- ExpansiÃ³n sin over-provisioning
- Mejor experiencia de usuario

---

## ğŸ§© Funcionalidades Incluidas

### Mejoras Backend

#### Caching Strategy

**Redis Distributed Cache:**
```typescript
// Estrategia de cachÃ© en capas
class CacheService {
  // CachÃ© Layer 1: En memoria local (5 min)
  // CachÃ© Layer 2: Redis compartido (30 min)
  // Source: PostgreSQL

  async getProducts(categoryId: string): Promise<Product[]> {
    const cacheKey = `products:${categoryId}`;

    // 1. Check Redis
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      this.metrics.recordCacheHit();
      return JSON.parse(cached);
    }

    // 2. Query DB
    const products = await this.productsRepository.find({
      where: { categoryId }
    });

    // 3. Cache in Redis (30 minutos)
    await this.redis.setEx(cacheKey, 1800, JSON.stringify(products));

    this.metrics.recordCacheMiss();
    return products;
  }

  // InvalidaciÃ³n inteligente
  async invalidateProductCache(productId: string) {
    const product = await this.productsRepository.findOne(productId);
    const cacheKey = `products:${product.categoryId}`;
    await this.redis.del(cacheKey);
    
    // Notificar a todos los clientes conectados
    await this.websocketService.broadcastCacheInvalidation(cacheKey);
  }
}
```

**QuÃ© cachear:**
- âœ… CatÃ¡logo de productos (invalidar cuando cambien)
- âœ… CategorÃ­as (invalidar cada 1 hora)
- âœ… Horarios de cafeterÃ­a (invalidar cada 6 horas)
- âœ… ConfiguraciÃ³n global (invalidar manual)
- âœ… Tops de productos (recalcular cada 1 hora)

**MÃ©tricas de cachÃ©:**
```json
{
  "cache_hit_rate": 0.85,  // 85% de hits
  "cache_miss_rate": 0.15, // 15% misses
  "avg_cached_size": "2.5 MB",
  "redis_memory_usage": "512 MB",
  "cache_evictions": 0,
  "cache_invalidations": 245
}
```

#### Database Optimization

**Read Replicas:**
```sql
-- Master: Escrituras
PRIMARY DB: Write operations
- CREATE operations
- UPDATE operations
- DELETE operations

-- Read Replicas: Lecturas
REPLICA 1: Read-heavy queries (menÃº, historial)
REPLICA 2: Analytics queries
REPLICA 3: Admin reports
```

**Query Optimization:**
```typescript
// Antes: N+1 queries
const orders = await Order.find()
  .populate('user')      // Query adicional por cada order
  .populate('items')     // Query adicional por cada order
  .populate('items.product'); // MÃ¡s queries

// DespuÃ©s: Single query optimizada
const orders = await Order.find()
  .leftJoinAndSelect('order.user', 'user')
  .leftJoinAndSelect('order.items', 'items')
  .leftJoinAndSelect('items.product', 'product')
  .where('order.created_at > :date', { date: yesterday })
  .getMany();
```

**Ãndices de Base de Datos:**
```sql
-- Ãndices clave
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_transactions_user_id ON transactions(user_id);
CREATE INDEX idx_notifications_user_id ON notifications(user_id, is_read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);

-- Ãndices compuestos
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_transactions_user_date ON transactions(user_id, created_at DESC);
```

**Connection Pooling:**
```typescript
const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: 5432,
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  entities: [...],
  synchronize: false,
  pool: {
    min: 10,
    max: 100,  // Aumentado de 20
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
  }
});
```

#### API Optimization

**Compression & Minification:**
```typescript
// Enable gzip compression
app.use(compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
  level: 6  // Nivel 6 de compresiÃ³n
}));
```

**Pagination & Lazy Loading:**
```typescript
@Get('/orders')
@Query('page', new DefaultValuePipe(1), ParseIntPipe)
@Query('limit', new DefaultValuePipe(20), ParseIntPipe)
async getOrders(
  @Query('page') page: number,
  @Query('limit') limit: number
) {
  const skip = (page - 1) * limit;
  
  const [data, total] = await this.ordersRepository.findAndCount({
    skip,
    take: limit,
    order: { createdAt: 'DESC' }
  });

  return {
    data,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    }
  };
}
```

**Field Selection:**
```typescript
// Cliente puede pedir solo los campos que necesita
GET /api/orders?fields=id,status,totalAmount,createdAt

// Backend implementa
const selectFields = fields.split(',');
const query = repository.createQueryBuilder()
  .select(selectFields.map(f => `orders.${f}`));
```

### Real-Time Architecture

#### WebSocket Optimization

```typescript
// Socket.io con adapter distribuido
import { IoAdapter } from '@nestjs/platform-socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

const pubClient = createClient({ host: 'redis', port: 6379 });
const subClient = pubClient.duplicate();

export class SocketIoAdapter extends IoAdapter {
  async connectAsync(server: any) {
    await Promise.all([pubClient.connect(), subClient.connect()]);
    const adapter = createAdapter(pubClient, subClient);
    server.io.adapter(adapter);
    return server;
  }
}

@WebSocketGateway({
  namespace: '/orders',
  transports: ['websocket', 'polling'],
  cors: true
})
export class OrdersGateway {
  @SubscribeMessage('order:subscribe')
  subscribeToOrder(
    @MessageBody() data: { orderId: string },
    @ConnectedSocket() socket: Socket
  ) {
    socket.join(`order:${data.orderId}`);
    return { status: 'subscribed' };
  }

  @SubscribeMessage('order:subscribe_live_feed')
  subscribeLiveFeed(
    @ConnectedSocket() socket: Socket
  ) {
    socket.join('orders:live');
    return { status: 'subscribed_to_live_feed' };
  }

  // Emitir a usuarios especÃ­ficos
  async notifyOrderUpdate(orderId: string, update: any) {
    this.server.to(`order:${orderId}`).emit('order:updated', update);
  }

  // Emitir a todos (nueva orden para admin)
  async broadcastNewOrder(order: any) {
    this.server.to('orders:live').emit('order:created', order);
  }
}
```

**Optimizaciones:**
- Redis Adapter para distribuir sockets entre servidores
- Namespaces separados por caracterÃ­stica
- Rooms para agrupar usuarios
- Heartbeat y keepalive configurado

### Mobile Performance

#### App Optimization

```typescript
// v1: App lista completa en memoria
const [products, setProducts] = useState([]);
useEffect(() => {
  api.get('/products').then(setProducts);
}, []);

// v3: VirtualizaciÃ³n y lazy loading
import { FlatList } from 'react-native';

<FlatList
  data={products}
  renderItem={renderProduct}
  keyExtractor={item => item.id}
  initialNumToRender={10}  // Renderizar solo 10 items
  maxToRenderPerBatch={20} // Aumentar de a 20
  updateCellsBatchingPeriod={50}
  removeClippedSubviews={true}
  CellRendererComponent={optimizedCell}
/>
```

**TamaÃ±o de app:**
- v1: 45 MB
- v3: 32 MB (bundle optimization)

#### Image Optimization

**Responsive Images:**
```typescript
// Generar mÃºltiples tamaÃ±os
const imageUrl = `${CDN_URL}/products/${id}`;

<Image
  source={{
    uri: imageUrl + '?w=300&h=300&q=80', // Mobile
    width: 300,
    height: 300
  }}
  style={styles.productImage}
/>

// Web (srcset)
<img
  src={`${CDN_URL}/products/${id}?w=400&h=400`}
  srcSet={`
    ${CDN_URL}/products/${id}?w=200&h=200 200w,
    ${CDN_URL}/products/${id}?w=400&h=400 400w,
    ${CDN_URL}/products/${id}?w=800&h=800 800w
  `}
/>
```

### Admin Panel Performance

#### Dashboard Real-Time

```typescript
// v1: Actualizar cada 30 segundos
setInterval(() => {
  fetchDashboard();
}, 30000);

// v3: WebSocket + local state updates
socket.on('order:accepted', (order) => {
  setDashboard(prev => ({
    ...prev,
    totalOrders: prev.totalOrders + 1,
    todayRevenue: prev.todayRevenue + order.totalAmount
  }));
});
```

#### Virtual Scrolling

```typescript
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={transactions.length}
  itemSize={60}
  width="100%"
>
  {({ index, style }) => (
    <TransactionRow 
      transaction={transactions[index]} 
      style={style}
    />
  )}
</FixedSizeList>
```

---

## ğŸ—ï¸ Arquitectura TÃ©cnica (v3)

### Escalabilidad Horizontal

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Load Balancer (ALB)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚           â”‚           â”‚
   â”Œâ”€â”€â”€â–¼â”€â”€â”    â”Œâ”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â–¼â”€â”€â”€â”
   â”‚API-1 â”‚    â”‚API-2 â”‚    â”‚API-3 â”‚ (Auto-Scaling)
   â”‚Pod   â”‚    â”‚Pod   â”‚    â”‚Pod   â”‚
   â””â”€â”€â”€â”¬â”€â”€â”˜    â””â”€â”€â”¬â”€â”€â”€â”˜    â””â”€â”€â”¬â”€â”€â”€â”˜
       â”‚          â”‚          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Shared Services       â”‚
              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
              â”‚ PostgreSQL (RDS)       â”‚
              â”‚ - Master (write)       â”‚
              â”‚ - Read Replica 1       â”‚
              â”‚ - Read Replica 2       â”‚
              â”‚ - Read Replica 3       â”‚
              â”‚                        â”‚
              â”‚ Redis Cluster          â”‚
              â”‚ (6 nodes)              â”‚
              â”‚                        â”‚
              â”‚ Firebase (FCM)         â”‚
              â”‚ Socket.io (distribuido)â”‚
              â”‚                        â”‚
              â”‚ S3 (CDN)               â”‚
              â”‚ CloudFront             â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server-v3
  labels:
    app: api-server
    version: v3
spec:
  replicas: 5  # Aumentado de 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: api-server
  template:
    metadata:
      labels:
        app: api-server
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - api-server
              topologyKey: kubernetes.io/hostname
      containers:
      - name: api-server
        image: registry.itsur.com/api-server:v3.0.0
        ports:
        - containerPort: 3000
        - containerPort: 6379  # Redis
        env:
        - name: NODE_ENV
          value: "production"
        - name: REDIS_URL
          value: "redis-cluster:6379"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-server-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-server-v3
  minReplicas: 5
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

### Redis Cluster Setup

```
# 6 nodes (3 master + 3 replica)
redis-1: Master
redis-2: Master
redis-3: Master
redis-4: Replica de redis-1
redis-5: Replica de redis-2
redis-6: Replica de redis-3

# ConfiguraciÃ³n
requirepass: strong_password
maxmemory: 2gb
maxmemory-policy: allkeys-lru
```

---

## ğŸ” Seguridad en v3

### Rate Limiting Mejorado

```typescript
// Sliding window rate limiter
import RedisStore from 'rate-limit-redis';

const limiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit:'
  }),
  windowMs: 60 * 1000,        // 1 minuto
  max: 100,                    // 100 requests
  message: 'Demasiadas solicitudes',
  standardHeaders: true,       // Retorna info en headers
  legacyHeaders: false
});

// Rate limits especÃ­ficos
const paymentLimiter = rateLimit({
  store: new RedisStore({ client: redisClient, prefix: 'payment:' }),
  windowMs: 15 * 60 * 1000,    // 15 minutos
  max: 10                      // 10 intentos
});

const loginLimiter = rateLimit({
  store: new RedisStore({ client: redisClient, prefix: 'login:' }),
  windowMs: 15 * 60 * 1000,    // 15 minutos
  max: 5                       // 5 intentos
});

@Post('/auth/login')
@UseGuards(loginLimiter)
login() { ... }
```

### DDoS Protection

```typescript
// Shield - protecciÃ³n contra DDoS
import shield from 'express-shield';

app.use(shield({
  csp: true,
  hsts: true,
  xframe: 'DENY',
  xss: true,
  nocache: true,
  nosniff: true
}));

// WAF rules
app.use((req, res, next) => {
  // Bloquear patrones sospechosos
  if (req.headers['user-agent']?.includes('bot')) {
    if (!APPROVED_BOTS.includes(req.headers['user-agent'])) {
      return res.status(403).send('Access Denied');
    }
  }
  next();
});
```

---

## ğŸ“Š Rendimiento - Benchmarks

### Before (v2) vs After (v3)

| MÃ©trica | v2 | v3 | Mejora |
|---------|-----|------|--------|
| API p95 latency | 450ms | 85ms | 81% â†“ |
| API p99 latency | 850ms | 150ms | 82% â†“ |
| Cache hit rate | 0% | 85% | - |
| Concurrent users | 1,000 | 5,000 | 5x |
| DB queries/sec | 5,000 | 2,000 | 60% â†“ |
| Memory per pod | 512MB | 512MB | - |
| Network bandwidth | 100Mbps | 250Mbps | - |
| Uptime | 99.5% | 99.99% | - |

### Load Test Results

```
Scenario: 5,000 usuarios simultÃ¡neos
DuraciÃ³n: 30 minutos

Resultados:
âœ… Mean response time: 85ms
âœ… Median: 72ms
âœ… p95: 95ms
âœ… p99: 150ms
âœ… Error rate: 0.02% (< 50 errores de 250,000 requests)
âœ… Successful orders: 12,500 durante test
âœ… Payment success rate: 98.5%
```

---

## ğŸ“Š Monitoreo Avanzado en v3

### MÃ©tricas Clave

```json
{
  "api_metrics": {
    "requests_per_second": 500,
    "average_response_time": "85ms",
    "p95_response_time": "95ms",
    "error_rate": "0.02%",
    "cache_hit_rate": "85%"
  },
  "database_metrics": {
    "query_time_p95": "25ms",
    "connections_active": 45,
    "replication_lag": "< 1ms",
    "disk_usage": "2.3 GB"
  },
  "infrastructure": {
    "pod_count": 8,
    "avg_cpu_utilization": "65%",
    "avg_memory_utilization": "72%",
    "redis_memory": "512MB",
    "network_bandwidth": "250Mbps"
  }
}
```

### Dashboards

```
Dashboard 1: Operacional
- API health
- Error rates
- Response times
- Active users

Dashboard 2: Base de Datos
- Query performance
- Replication lag
- Connection pool usage
- Storage usage

Dashboard 3: Infraestructura
- Pod scaling events
- Resource utilization
- Network usage
- Disk I/O
```

---

## ğŸš€ PreparaciÃ³n para ProducciÃ³n en v3

### Rollout Strategy

```
Fase 1: Canary (5% trÃ¡fico)
- Monitor 2 horas
- Verificar metrics normales
- Rollback automÃ¡tico si error rate > 1%

Fase 2: Progressive (25% â†’ 50% â†’ 100%)
- Aumentar cada 30 minutos
- Alertas activas
- Team en espera

Fase 3: Full Production
- Monitoreo 24/7
- SLA compliance verificado
```

### Backup & Disaster Recovery

```
Estrategia de Backup (v3):
- Base de datos: Snapshots cada 1 hora
- Redis: Snapshots cada 30 minutos
- ConfiguraciÃ³n: Versionada en Git

Recovery:
- RTO: 30 minutos
- RPO: 15 minutos
- Test de DR cada 2 semanas
```

---

## ğŸ“ Entregables de v3

```
âœ… Optimization Report
   - Cache strategy
   - Query optimization
   - Load test results

âœ… Scaled Infrastructure
   - Kubernetes manifests
   - Redis cluster config
   - Auto-scaling setup

âœ… Performance Baselines
   - Metrics dashboards
   - Alert configurations
   - SLA compliance docs

âœ… Mobile Optimization
   - Reduced APK size
   - Virtual scrolling
   - Image optimization

âœ… Documentation
   - Scaling guide
   - Performance tuning
   - Disaster recovery plan
```

---

## ğŸ“Œ Siguiente Fase (v4.0.0)

â†’ **v4.0.0 â€” Analytics & Intelligence**

Con 5,000 usuarios y datos histÃ³ricos:
- Dashboard de analÃ­tica avanzada
- PredicciÃ³n de demanda con ML
- Reportes de negocio
- SegmentaciÃ³n de usuarios
- A/B testing framework

**Estimado**: 6 semanas despuÃ©s de v3

---

**Documento creado**: 20 Enero 2026
**Estado**: EspecificaciÃ³n TÃ©cnica Completa
**Performance Target**: 99.99% uptime, <100ms latency
